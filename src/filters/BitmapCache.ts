import DisplayObject from "../display/DisplayObject";
import StageGL from "../display/StageGL";
import Rectangle from "../geom/Rectangle";
import Matrix2D from "../geom/Matrix2D";
import createCanvas from "../utils/Canvas";

import Filter from "./Filter";

export default class BitmapCache {

    public width: number = 0;
    public height: number = 0;
    x: number = 0;
    y: number = 0;
    scale: number = 1;
    offX: number = 0;
    offY: number = 0;
    public cacheID: number = 0;
    protected target: any;
    protected _options?: any;

    _filterCount: number = 0;
    _filterOffX: number = 0;
    _filterOffY: number = 0;

    protected _disabled: boolean = false;
    public _autoGenerated: boolean = false;

    public _cacheCanvas?: HTMLCanvasElement|WebGLTexture|any;
    protected _stageGL?: StageGL|any;
    protected _cacheDataURLID: number = 0;
    protected _cacheDataURL?: string;

    _drawWidth: number = 0;
    _drawHeight: number = 0;

    protected _boundRect = new Rectangle();

    // semi protected: not public API but modified by other classes
    _counterMatrix?: Matrix2D;
    _bufferTextureOutput?: WebGLTexture;
    _bufferTextureConcat?: WebGLTexture;
    _bufferTextureTemp?: WebGLTexture;

    public set disabled(value: boolean) {
        this._disabled = !!value;
        if (this.target) {
            this.target.cacheCanvas = (this._disabled || this._autoGenerated) ? null : this._cacheCanvas;
        }
    }

    public get disabled(): boolean {
        return this._disabled;
    }

    public static getFilterBounds(target: DisplayObject, output?: Rectangle): Rectangle {
        if (!output){ output = new Rectangle(); }
        const filters = target.filters;
        const filterCount = filters && filters.length;
        if (!filterCount || filterCount <= 0) { return output; }

        for (let i=0; i<filterCount; i++) {
            const f = filters && filters[i];
            if (!f || !f.bounds){ continue; }
            const test = f.bounds;
            if (!test){ continue; }
            if (i === 0) {
                output.copy(test);
            } else {
                output.extend(test);
            }
        }

        return output;
    }

    public static filterCounter(acc: any, o: Filter): any {
        let out = 1;
        while (o._multiPass) {
            o = o._multiPass;
            out++;
        } return acc + out;
    }

    public toString(): string {
        return "[BitmapCache]";
    }

    public define(target: DisplayObject, x: number, y: number, width: number, height: number, scale: number = 1, options?: any) {
        if (!target){ throw "No symbol to cache"; }
        this._options = options;
        this.target = target;

        this.width =		width >= 1 ? width : 1;
        this.height =		height >= 1 ? height : 1;
        this.x =			x || 0;
        this.y =			y || 0;
        this.scale =		scale || 1;

        this.update();
    }

    public update(compositeOperation?: CompositeOperation) {
        if (!this.target) { throw "define() must be called before update()"; }

        const filterBounds = BitmapCache.getFilterBounds(this.target);
        const surface = this._cacheCanvas;

        this._drawWidth = Math.ceil(this.width*this.scale) + filterBounds.width;
        this._drawHeight = Math.ceil(this.height*this.scale) + filterBounds.height;
        this._filterCount = this.target.filters && this.target.filters.reduce(BitmapCache.filterCounter, 0);

        if (!surface || this._drawWidth !== surface.width || this._drawHeight !== surface.height) {
            this._updateSurface();
        }

        if (this._stageGL) {
            if (this._bufferTextureOutput === null) {
                this._bufferTextureOutput = this._stageGL.getRenderBufferTexture(this._drawWidth, this._drawHeight);
            } else {
                this._stageGL.resizeTexture(this._bufferTextureOutput, this._drawWidth, this._drawHeight);
            }

            if (this._cacheCanvas === null){
                this._cacheCanvas = this._bufferTextureOutput;
                this.disabled = this._disabled;
            }
            if (this._filterCount >= 1) {
                if (this._bufferTextureConcat === null) {
                    this._bufferTextureConcat = this._stageGL.getRenderBufferTexture(this._drawWidth, this._drawHeight);
                } else {
                    this._stageGL.resizeTexture(this._bufferTextureConcat, this._drawWidth, this._drawHeight);
                }
            }
        }

        this._filterOffX = filterBounds.x;
        this._filterOffY = filterBounds.y;
        this.offX = this.x*this.scale + this._filterOffX;
        this.offY = this.y*this.scale + this._filterOffY;

        this._drawToCache(compositeOperation);

        this.cacheID = this.cacheID?this.cacheID+1:1;
    }

    public release() {
        if (this._stageGL) {
            if (this._bufferTextureOutput !== null){ this._stageGL._killTextureObject(this._bufferTextureOutput); }
            if (this._bufferTextureConcat !== null){ this._stageGL._killTextureObject(this._bufferTextureConcat); }
            if (this._bufferTextureTemp !== null){ this._stageGL._killTextureObject(this._bufferTextureTemp); }
            // set the context to none and let the garbage collector get the rest when the canvas itself gets removed
            this._stageGL = undefined;
        } else {
            const stage = this.target.stage;
            if (stage instanceof StageGL) {
                stage.releaseTexture(this._cacheCanvas);
            }
        }

        this.disabled = true;
        this.target = this._cacheCanvas = this._cacheDataURL = undefined;
        this.cacheID = this._cacheDataURLID = 0;
        this.width = this.height = this.x = this.y = this.offX = this.offY = 0;
        this.scale = 1;
    }

    public getCacheDataURL(type: any, encoderOptions: any): string|null {
        const cacheCanvas = this.target && this._cacheCanvas;
        if (!cacheCanvas) { return null; }
        if (this.cacheID !== this._cacheDataURLID) {
            this._cacheDataURLID = this.cacheID;
            this._cacheDataURL = cacheCanvas.getCacheDataURL ? cacheCanvas.getCacheDataURL(type, encoderOptions) : undefined;
        }
        return this._cacheDataURL||null;
    }

    public draw(ctx: CanvasRenderingContext2D): boolean {
        if (!this._cacheCanvas) {
            return false;
        }
        ctx.drawImage(this._cacheCanvas,
            this.x + (this._filterOffX/this.scale),this.y + (this._filterOffY/this.scale),
            this._drawWidth/this.scale,this._drawHeight/this.scale
        );
        return true;
    }

    public get bounds(): Rectangle {
        const scale = this.scale;
        return this._boundRect.setValues(
            this.x, this.y,
            this.width/scale,this.height/scale
        );
    }

    public _getGLFilter(lookup: number): Filter|undefined {
        if (this.target.filters === null || lookup < 0){ return undefined; }
        let i = 0;
        let result = this.target.filters[i];
        while (result && --lookup >= 0) {
            result = result._multiPass ? result._multiPass : this.target.filters[++i];
        }
        return result;
    }

    protected _updateSurface() {
        let surface;

        if (!this._options || !this._options.useGL) {
            surface = this._cacheCanvas;

            // create it if it's missing
            if (!surface) {
                surface = this._cacheCanvas = createCanvas ? createCanvas() : document.createElement("canvas");
                this.disabled = this._disabled;
            }

            // now size it
            surface.width = this._drawWidth;
            surface.height = this._drawHeight;
            return;
        }

        // create it if it's missing
        if (!this._stageGL) {
            if (this._options.useGL === "stage") {
                const targetStage = this.target.stage;
                // use the stage that this object belongs on as the WebGL context
                if (!(targetStage && targetStage.isWebGL)){
                    let error = "Cannot use 'stage' for cache because the object's parent stage is ";
                    error += targetStage ? "non WebGL." : "not set, please addChild to the correct stage.";
                    throw error;
                }
                this._stageGL = targetStage;

            } else if (this._options.useGL === "new") {
                // create a new WebGL context to run this cache
                this._cacheCanvas = document.createElement("canvas"); // low autopurge in case of filter swapping and low texture count
                this._stageGL = new StageGL(this._cacheCanvas, {antialias: true, transparent: true, autoPurge: 10});
                if (!this._stageGL._webGLContext){ throw "GL Cache asked for but unavailable"; }
                this._stageGL.isCacheControlled = true;	// use this flag to control stage sizing and final output

            } else if (this._options.useGL instanceof StageGL) {
                // use the provided WebGL context to run this cache, trust the user it works and is configured.
                this._stageGL = this._options.useGL;

            } else {
                throw "Invalid option provided to useGL, expected ['stage', 'new', StageGL, undefined], got "+ this._options.useGL;
            }
        }

        this.disabled = this._disabled;

        // if we have a dedicated stage we've got to size it
        const stageGL = this._stageGL;
        if (stageGL.isCacheControlled) {
            surface = this._cacheCanvas;
            surface.width = this._drawWidth;
            surface.height = this._drawHeight;
            stageGL.updateViewport(this._drawWidth, this._drawHeight);
        }
    }

    /**
     * Perform the cache draw out for context 2D now that the setup properties have been performed.
     **/
    protected _drawToCache(compositeOperation?: CompositeOperation) {
        const surface = this._cacheCanvas;
        const target = this.target;
        const webGL = this._stageGL;

        if (webGL) {
            webGL.cacheDraw(target, this);
        } else {
            const ctx = surface.getContext("2d");

            if (!compositeOperation) {
                ctx.clearRect(0, 0, this._drawWidth+1, this._drawHeight+1);
            }

            ctx.save();
            ctx.globalCompositeOperation = compositeOperation;
            ctx.setTransform(this.scale,0,0,this.scale, -this._filterOffX,-this._filterOffY);
            ctx.translate(-this.x, -this.y);
            target.draw(ctx, true);
            ctx.restore();

            if (target.filters && target.filters.length) {
                this._applyFilters(ctx);
            }
        }
        surface._invalid = true;
    }

    public _applyFilters(ctx: CanvasRenderingContext2D) {
        const filters: Filter[] = this.target.filters;

        const w = this._drawWidth;
        const h = this._drawHeight;

        let data;

        let i = 0, filter = filters[i];
        do { // this is safe because we wouldn't be in apply filters without a filter count of at least 1
            if (filter.usesContext){
                if (data) {
                    ctx.putImageData(data, 0,0);
                    data = null;
                }
                filter.applyFilter(ctx, 0,0, w,h);
            } else {
                if (!data) {
                    data = ctx.getImageData(0,0, w,h);
                }
                filter._applyFilter(data);
            }

            // work through the multipass if it's there, otherwise move on
            filter = filter._multiPass !== null ? filter._multiPass : filters[++i];
        } while (filter);

        //done
        if (data) {
            ctx.putImageData(data, 0,0);
        }
    }
}